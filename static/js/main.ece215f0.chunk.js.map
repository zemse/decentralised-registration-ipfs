{"version":3,"sources":["logo.svg","env.js","ipfs-utils.js","components/LoadWallet/LoadWallet.js","components/Home/UserDashboard/EditProfile/EditProfile.js","components/Home/UserDashboard/UserDashboard.js","components/Home/PublicTimeline/TimelineElement/TimelineElement.js","components/Home/PublicTimeline/PublicTimeline.js","components/Home/Home.js","App.js","serviceWorker.js","index.js","enums.js"],"names":["module","exports","network","dReg","abi","require","address","ipfs","infura","host","port","protocol","IPFS","bs58","ethers","ipfsClient","input","a","slice","utils","arrayify","toUtf8Bytes","Uint8Array","filter","n","length","window","ssss","console","log","first","Array","isArray","second","Error","asyncGenerator","add","next","output","value","path","ipfsHash","get","contentGenerator","content","_bufs","multihashToBytes32","decoded","decode","toMultihash","bytes32","hex","hexlify","encode","concat","openEraSwapLife","open","render","onClick","wallet","Wallet","createRandom","connect","getDefaultProvider","Component","ipfsUtils","state","name","location","bio","ipfsStatus","IPFS_ADD_STATUS_ENUM","IDLE","txStatus","ETH_TX_CONFIRM_ENUM","errorMessage","componentDidMount","profileObj","setState","props","hideProfile","placeholder","onChange","event","target","disabled","UPLOADING","data","version","bytes","JSON","stringify","UPLOADED","message","SIGNING","dRegContract","functions","updateProfile","tx","hash","WAITING","wait","CONFIRMED","updateProfileObj","registrationStatus","REGISTRATION_STATUS_ENUM","CHECKING","ipfsGetStatus","IPFS_GET_STATUS_ENUM","showEditProfile","profiles","profileStruct","ipfsSha256Hash","constants","HashZero","NOT_REGISTERED","REGISTERED","LOADING","error","parse","toUtf8String","LOADED","NOT_FOUND","userAddress","multiHash","h","class","className","fetchingLogs","logs","newLogs","updateLogs","provider","on","filters","ProfileUpdated","getLogs","fromBlock","toBlock","map","interface","parseLog","reverse","i","values","_userAddress","_ipfsSha256Hash","key","showTimeLine","setInterval","walletLoaded","undefined","Boolean","hostname","match","Contract","addEventListener","e","setTimeout","ProcessParentMessage_2","substring","ReactDOM","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch"],"mappings":"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","file":"static/js/main.ece215f0.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","const network = 'kovan';\n\nmodule.exports = {\n  network,\n  dReg: {\n    abi: require('./ethereum/abi/dReg.json'),\n    address: (() => {\n      switch(network) {\n        case 'kovan':\n          return '0x5149067BD6EDa621dF2201b6BDCC3494bAe349C9';\n        default:\n          return null;\n      }\n    })()\n  },\n  ipfs: {\n    infura: {\n      host: 'ipfs.infura.io',\n      port: 5001,\n      protocol: 'https'\n    }\n  }\n};\n","const { ipfs } = require('./env');\nconst IPFS = require('ipfs-http-client');\nconst bs58 = require('bs58');\nconst ethers = require('ethers');\n\nconst ipfsClient = new IPFS(ipfs.infura);\n\n// data should be hex string or uint8 array\nasync function add(input) {\n  let data;\n  if(typeof input === 'string') {\n    if(input.slice(0, 2) === '0x') {\n      data = ethers.utils.arrayify(input);\n    } else {\n      data = ethers.utils.toUtf8Bytes(input);\n    }\n  } else if(input instanceof Uint8Array && input.filter(n => n >= 256).length === 0) {\n    data = input;\n  } else {\n    window.ssss = input;\n    console.log({input, first: Array.isArray(input), second: input.filter(n => n >= 256).length === 0});\n    throw new Error('Invalid input: ' + input);\n  }\n\n  const asyncGenerator = ipfsClient.add(input);\n  const output = await asyncGenerator.next();\n  return output.value.path;\n}\n\nasync function get(ipfsHash) {\n  const asyncGenerator = ipfsClient.get(ipfsHash);\n  const output = await asyncGenerator.next();\n  const contentGenerator = output.value.content;\n  const content = await contentGenerator.next();\n  // console.log({content});\n  return content.value._bufs.length === 1\n    ? content.value._bufs[0]\n    : content.value._bufs;\n}\n\nfunction multihashToBytes32(ipfsHash) {\n  const decoded = bs58.decode(ipfsHash);\n  if(decoded.length !== 34) throw new Error(`Invalid IPFS Hash Size: ${decoded.length} bytes`);\n  return decoded.slice(2);\n}\n\nfunction toMultihash(bytes32) {\n  const hex = ethers.utils.hexlify(bytes32);\n  return bs58.encode(ethers.utils.concat(['0x1220', hex]));\n}\n\nmodule.exports = { bs58, add, get, multihashToBytes32, toMultihash };\n","import React, { Component } from 'react';\nimport { network } from '../../env';\n\nconst ethers = require('ethers');\n\nexport default class extends Component {\n  openEraSwapLife = () => {\n    window.open('https://eraswap.life/','','width=1001,height=650');\n  }\n\n  render = () => (\n    <>\n      <button onClick={this.openEraSwapLife}>Load Wallet Using Era Swap Life</button>\n      <button onClick={() => window.wallet = ethers.Wallet.createRandom().connect(ethers.getDefaultProvider(network))}>Random Wallet</button>\n    </>\n  );\n}\n","import React, { Component } from 'react';\nimport { IPFS_ADD_STATUS_ENUM, ETH_TX_CONFIRM_ENUM } from '../../../../enums';\nconst ethers = require('ethers');\nconst ipfsUtils = require('../../../../ipfs-utils');\n\nexport default class extends Component {\n  state = {\n    name: '',\n    location: '',\n    bio: '',\n    ipfsHash: null,\n    ipfsStatus: IPFS_ADD_STATUS_ENUM.IDLE,\n    txStatus: ETH_TX_CONFIRM_ENUM.IDLE,\n    errorMessage: ''\n  };\n\n  componentDidMount = () => {\n    if(window.profileObj) {\n      this.setState({\n        name: window.profileObj.name,\n        location: window.profileObj.location,\n        bio: window.profileObj.bio\n      });\n    }\n  };\n\n  render = () => {\n    return (\n      <>\n        <p><button onClick={this.props.hideProfile}>{'<< Go Back'}</button> Register form</p>\n        Name: <input\n          placeholder=\"Enter your name\"\n          value={this.state.name}\n          onChange={event => this.setState({ name: event.target.value })}\n          /><br />\n        Location: <input\n          placeholder=\"Enter your location\"\n          value={this.state.location}\n          onChange={event => this.setState({ location: event.target.value })}\n          /><br />\n        Bio: <textarea\n          placeholder=\"Tell me about yourself\"\n          value={this.state.bio}\n          onChange={event => this.setState({ bio: event.target.value })}\n          ></textarea>\n        <button disabled={this.state.ipfsStatus !== IPFS_ADD_STATUS_ENUM.IDLE} onClick={async() => {\n          try {\n            this.setState({ ipfsStatus: IPFS_ADD_STATUS_ENUM.UPLOADING });\n            const data = {\n              version: 1,\n              name: this.state.name,\n              location: this.state.location,\n              bio: this.state.bio\n            };\n            const bytes = ethers.utils.toUtf8Bytes(JSON.stringify(data));\n            const ipfsHash = await ipfsUtils.add(bytes);\n            this.setState({ ipfsHash, ipfsStatus: IPFS_ADD_STATUS_ENUM.UPLOADED });\n          } catch (error) {\n            this.setState({\n              errorMessage: error.message,\n              ipfsStatus: IPFS_ADD_STATUS_ENUM.IDLE\n            });\n          }\n        }}>{(() => {\n          switch(this.state.ipfsStatus) {\n            case IPFS_ADD_STATUS_ENUM.IDLE:\n              return <>Generate IPFS Hash</>;\n            case IPFS_ADD_STATUS_ENUM.UPLOADING:\n              return <>Uploading...</>;\n            case IPFS_ADD_STATUS_ENUM.UPLOADED:\n              return <>Uploaded!</>;\n          }\n        })()}</button>\n        {this.state.ipfsHash ? <>\n          New IPFS Hash: {this.state.ipfsHash}\n          <button disabled={this.state.txStatus !== ETH_TX_CONFIRM_ENUM.IDLE} onClick={async() => {\n            this.setState({ txStatus: ETH_TX_CONFIRM_ENUM.SIGNING });\n            const bytes32 = ipfsUtils.multihashToBytes32(this.state.ipfsHash);\n            const tx = await window.dRegContract.functions.updateProfile(bytes32);\n            console.log(tx.hash);\n            this.setState({ txStatus: ETH_TX_CONFIRM_ENUM.WAITING });\n            await tx.wait();\n            this.setState({ txStatus: ETH_TX_CONFIRM_ENUM.CONFIRMED });\n            this.props.updateProfileObj(this.state.ipfsHash);\n          }}>{(() => {\n            switch(this.state.txStatus) {\n              case ETH_TX_CONFIRM_ENUM.IDLE:\n                return <>Sign and Submit Update Profile Tx</>;\n              case ETH_TX_CONFIRM_ENUM.SIGNING:\n                return <>Signing...</>;\n              case ETH_TX_CONFIRM_ENUM.WAITING:\n                return <>Waiting for confirmation</>;\n              case ETH_TX_CONFIRM_ENUM.CONFIRMED:\n                return <>Profile Updated</>;\n            }\n          })()}</button>\n          <br />\n          {this.state.txStatus === ETH_TX_CONFIRM_ENUM.CONFIRMED ? <button onClick={this.props.hideProfile}>Back to Home</button> : null}\n        </> : null}\n      </>\n    );\n  }\n}\n","import React, { Component } from 'react';\nimport { dReg, network, ipfs } from '../../../env';\nimport { REGISTRATION_STATUS_ENUM, IPFS_GET_STATUS_ENUM } from '../../../enums';\n\nimport EditProfile from './EditProfile/EditProfile';\n\nconst ethers = require('ethers');\nconst ipfsUtils = require('../../../ipfs-utils');\n\nexport default class extends Component {\n  state = {\n    registrationStatus: REGISTRATION_STATUS_ENUM.CHECKING,\n    ipfsGetStatus: IPFS_GET_STATUS_ENUM.IDLE,\n    // profileObj: null,\n    showEditProfile: false,\n    errorMessage: ''\n  };\n\n  componentDidMount = async() => {\n    // window.dRegContract = new ethers.Contract(dReg.address, dReg.abi, ethers.getDefaultProvider(network));\n    //\n    // window.dRegContract = window.dRegContract.connect(window.wallet);\n\n    const profileStruct = await window.dRegContract.functions.profiles(window.wallet.address);\n\n    await this.setState({\n      registrationStatus: profileStruct.ipfsSha256Hash === ethers.constants.HashZero\n        ? REGISTRATION_STATUS_ENUM.NOT_REGISTERED\n        : REGISTRATION_STATUS_ENUM.REGISTERED,\n      ipfsGetStatus: IPFS_GET_STATUS_ENUM.LOADING\n    });\n\n    if(this.state.registrationStatus === REGISTRATION_STATUS_ENUM.REGISTERED) {\n      this.updateProfileObj(profileStruct.ipfsSha256Hash);\n    }\n  }\n\n  updateProfileObj = async hash => {\n    try {\n      let ipfsHash = hash;\n      try {\n        ipfsHash = ipfsUtils.toMultihash(hash);\n      } catch (error) {}\n      const bytes = await ipfsUtils.get(ipfsHash);\n\n      const profileObj = JSON.parse(ethers.utils.toUtf8String(bytes));\n      console.log({profileObj});\n\n      window.profileObj = profileObj;\n\n      this.setState({\n        ipfsGetStatus: IPFS_GET_STATUS_ENUM.LOADED,\n        // profileObj\n      });\n    } catch (error) {\n      console.log(error);\n      this.setState({\n        errorMessage: error.message,\n        ipfsGetStatus: IPFS_GET_STATUS_ENUM.NOT_FOUND,\n      });\n    }\n  };\n\n  render = () => {\n    return (\n      <>\n        {\n          !this.state.showEditProfile\n          ? <>\n            <p>{(() => {\n              switch(this.state.registrationStatus) {\n                case REGISTRATION_STATUS_ENUM.CHECKING:\n                  return <>Checking your registration status...</>;\n                case REGISTRATION_STATUS_ENUM.NOT_REGISTERED:\n                  return <>You have not registered.<br />\n                  <button onClick={() => this.setState({\n                    showEditProfile: true\n                  })}>Register Now</button></>;\n                case REGISTRATION_STATUS_ENUM.REGISTERED:\n                  return <>\n                    You are registered<br />\n                    {(() => {\n                      switch(this.state.ipfsGetStatus) {\n                        case IPFS_GET_STATUS_ENUM.LOADING:\n                          return <>Fetching your profile details from IPFS...</>;\n                        case IPFS_GET_STATUS_ENUM.LOADED:\n                          return <>\n                            Successfully, fetched your profile from IPFS.<br />\n                            <button onClick={() => this.setState({\n                              showEditProfile: true\n                            })}>Edit Profile</button>\n                          </>;\n                        case IPFS_GET_STATUS_ENUM.NOT_FOUND:\n                          return <>Looks like your profile was dropped from IPFS, kindly re-update your profile.</>;\n                      }\n                    })()}\n                  </>;\n                default:\n                  return null;\n              }\n            })()}</p>\n          </>\n          : <EditProfile\n              hideProfile={() => this.setState({ showEditProfile: false })}\n              updateProfileObj={this.updateProfileObj}\n            />\n        }\n      </>\n    );\n  }\n}\n","import React, { Component } from 'react';\n\nconst ethers = require('ethers');\nconst ipfsUtils = require('../../../../ipfs-utils');\n\nexport default class extends Component {\n  state = {\n    userAddress: null,\n    multiHash: null,\n    name: null,\n    location: null,\n    bio: null\n  };\n\n  componentDidMount = async() => {\n    const userAddress = this.props.userAddress;\n    const ipfsSha256Hash = this.props.ipfsSha256Hash;\n    const multiHash = ipfsUtils.toMultihash(ipfsSha256Hash);\n\n    console.log(`h: ${this.props.h}`, {ipfsSha256Hash}, {multiHash});\n    this.setState({ userAddress, multiHash });\n\n\n    const bytes = await ipfsUtils.get(multiHash);\n\n    const profileObj = JSON.parse(ethers.utils.toUtf8String(bytes));\n    // console.log({profileObj});\n    this.setState({\n      name: profileObj.name,\n      location: profileObj.location,\n      bio: profileObj.bio,\n    });\n  };\n\n  render = () => {\n    return (\n      <div class=\"timeline-element\">\n        <span className=\"el-key\">Address:</span> {this.state.userAddress}<br />\n        <span className=\"el-key\">IPFS:</span> {this.state.multiHash}<br />\n        <span className=\"el-key\">Name:</span> {this.state.name}<br />\n        <span className=\"el-key\">Location:</span> {this.state.location}<br />\n        <span className=\"el-key\">Bio:</span> {this.state.bio}\n      </div>\n    );\n  }\n}\n","import React, { Component } from 'react';\nimport TimelineElement from './TimelineElement/TimelineElement';\n\nconst ethers = require('ethers');\nconst ipfsUtils = require('../../../ipfs-utils');\n\nexport default class extends Component {\n  state = {\n    fetchingLogs: true,\n    logs: [],\n    newLogs: []\n  };\n\n  componentDidMount = async() => {\n    this.updateLogs();\n\n    window.wallet.provider.on(window.dRegContract.filters.ProfileUpdated(), log => {\n      // const parsed = window.dRegContract.interface.parseLog(log);\n      // // console.log('parsed', parsed);\n      // const newLogs = [parsed, ...this.state.newLogs];\n      // // console.log('new logs', newLogs);\n      // this.setState({ newLogs });\n\n      this.updateLogs();\n    });\n  }\n\n  updateLogs = async() => {\n    this.setState({ fetchingLogs: true });\n\n    const logs = (await window.wallet.provider.getLogs({\n      ...window.dRegContract.filters.ProfileUpdated(),\n      fromBlock: 0,\n      toBlock: 'latest'\n    })).map(log => window.dRegContract.interface.parseLog(log)).reverse();\n    console.log({logs});\n\n    this.setState({ logs, fetchingLogs: false });\n  }\n\n  render = () => {\n    return (\n      <>\n        {\n          this.state.fetchingLogs\n          ? <p>Please wait fetching logs...</p>\n          : <>\n\n            {this.state.logs.map((log, i) => {\n              const userAddress = log.values._userAddress;\n              const ipfsSha256Hash = log.values._ipfsSha256Hash;\n              return <TimelineElement\n                key={i}\n                userAddress={userAddress}\n                ipfsSha256Hash={ipfsSha256Hash}\n                h={i}\n                />\n            })}\n          </>\n        }\n      </>\n    );\n  }\n}\n","import React, { Component } from 'react';\nimport { dReg, network, ipfs } from '../../env';\nimport { REGISTRATION_STATUS_ENUM, IPFS_GET_STATUS_ENUM } from '../../enums';\n\nimport UserDashboard from './UserDashboard/UserDashboard';\nimport EditProfile from './UserDashboard/EditProfile/EditProfile';\nimport PublicTimeline from './PublicTimeline/PublicTimeline';\n\nconst ethers = require('ethers');\nconst ipfsUtils = require('../../ipfs-utils');\n\nexport default class extends Component {\n  state = {\n    name: null,\n    showTimeLine: false,\n  };\n\n  componentDidMount = () => {\n    setInterval(() => {\n      if(window.profileObj && window.profileObj.name !== this.state.name) {\n        this.setState({ name: window.profileObj.name });\n      }\n    }, 100);\n  };\n\n  render = () => {\n    return (\n      <>\n        <p>Welcome {this.state.name ? <>{this.state.name}</> : <>{window.wallet.address}</>}!</p>\n        {\n          !this.state.showTimeLine\n          ? <>\n              <UserDashboard />\n              <button onClick={() => this.setState({ showTimeLine: true })}>Show Public Timeline</button>\n            </>\n          : <>\n              <button onClick={() => this.setState({ showTimeLine: false })}>Show My Dashboard</button>\n              <PublicTimeline />\n            </>\n        }\n      </>\n    );\n  }\n}\n","import React, { Component } from 'react';\nimport logo from './logo.svg';\nimport './App.css';\n\nimport LoadWallet from './components/LoadWallet/LoadWallet';\nimport Home from './components/Home/Home';\n\nexport default class extends Component {\n  state = {\n    walletLoaded: false\n  };\n\n  componentDidMount = () => {\n    setInterval(() => {\n      const walletLoaded = window.wallet !== undefined;\n      if(walletLoaded !== this.state.walletLoaded) {\n        this.setState({ walletLoaded });\n      }\n    }, 100);\n  };\n\n  render = () => (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        {\n          !this.state.walletLoaded\n          ? <LoadWallet />\n          : <Home />\n        }\n      </header>\n    </div>\n  );\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport { dReg, network } from './env';\n\nconst ethers = require('ethers');\nconst ipfsUtils = require('./ipfs-utils');\n\nwindow.ethers = ethers;\nwindow.ipfsUtils = ipfsUtils;\n\nwindow.dRegContract = new ethers.Contract(dReg.address, dReg.abi, ethers.getDefaultProvider(network));\n\n// for development\n// window.wallet = (new ethers.Wallet(\n//   '24C4FE6063E62710EAD956611B71825B778B041B18ED53118CE5DA5F02E494BA'))\n//   .connect(ethers.getDefaultProvider(network));\n// window.dRegContract = window.dRegContract.connect(window.wallet);\n\nwindow.addEventListener('message', function(e) {\n  setTimeout(() => {\n    window.ProcessParentMessage_2(e.data);\n  }, 0);\n} , false);\n\nwindow.ProcessParentMessage_2 = message => {\n  if(typeof message === 'string'){\n    if(message.substring(0,2) === \"0x\"){\n      window.wallet = (new ethers.Wallet(message)).connect(ethers.getDefaultProvider(network));\n      window.dRegContract = window.dRegContract.connect(window.wallet);\n    }\n  }\n}\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","const REGISTRATION_STATUS_ENUM = {\n  CHECKING: 0,\n  NOT_REGISTERED: 1,\n  REGISTERED: 2\n};\n\nconst IPFS_ADD_STATUS_ENUM = {\n  IDLE: 0,\n  UPLOADING: 1,\n  UPLOADED: 2\n};\n\nconst IPFS_GET_STATUS_ENUM = {\n  IDLE: 0,\n  LOADING: 1,\n  LOADED: 2,\n  NOT_FOUND: 3\n};\n\nconst ETH_TX_CONFIRM_ENUM = {\n  IDLE: 0,\n  SIGNING: 1,\n  WAITING: 2,\n  CONFIRMED: 3\n}\n\nmodule.exports = { REGISTRATION_STATUS_ENUM, IPFS_ADD_STATUS_ENUM, IPFS_GET_STATUS_ENUM, ETH_TX_CONFIRM_ENUM };\n"],"sourceRoot":""}