{"version":3,"sources":["logo.svg","env.js","components/LoadWallet/LoadWallet.js","ipfs-utils.js","components/Home/UserDashboard/EditProfile/EditProfile.js","components/Home/UserDashboard/UserDashboard.js","components/Home/PublicTimeline/TimelineElement/TimelineElement.js","components/Home/PublicTimeline/PublicTimeline.js","components/Home/Home.js","App.js","serviceWorker.js","index.js","enums.js"],"names":["module","exports","network","dReg","abi","require","address","ipfs","infura","host","port","protocol","ethers","openEraSwapLife","window","open","render","onClick","wallet","Wallet","createRandom","connect","getDefaultProvider","Component","IPFS","bs58","ipfsClient","input","a","slice","utils","arrayify","toUtf8Bytes","Uint8Array","filter","n","length","ssss","console","log","first","Array","isArray","second","Error","asyncGenerator","add","next","output","value","path","ipfsHash","get","contentGenerator","content","_bufs","ipfsUtils","multihashToBytes32","decoded","decode","toMultihash","bytes32","hex","hexlify","encode","concat","state","name","location","url","bio","ipfsStatus","IPFS_ADD_STATUS_ENUM","IDLE","txStatus","ETH_TX_CONFIRM_ENUM","errorMessage","componentDidMount","profileObj","setState","props","hideProfile","placeholder","onChange","event","target","disabled","UPLOADING","data","version","bytes","JSON","stringify","UPLOADED","message","SIGNING","dRegContract","functions","updateProfile","tx","hash","WAITING","wait","CONFIRMED","updateProfileObj","registrationStatus","REGISTRATION_STATUS_ENUM","CHECKING","ipfsGetStatus","IPFS_GET_STATUS_ENUM","showEditProfile","profiles","profileStruct","ipfsSha256Hash","constants","HashZero","NOT_REGISTERED","REGISTERED","LOADING","error","parse","toUtf8String","LOADED","NOT_FOUND","userAddress","multiHash","h","class","className","href","fetchingLogs","logs","newLogs","updateLogs","provider","on","filters","ProfileUpdated","getLogs","fromBlock","toBlock","map","interface","parseLog","reverse","i","values","_userAddress","_ipfsSha256Hash","key","showTimeLine","setInterval","walletLoaded","undefined","Boolean","hostname","match","Contract","addEventListener","e","setTimeout","ProcessParentMessage_2","substring","ReactDOM","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch"],"mappings":"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","file":"static/js/main.ec501aa7.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","const network = 'kovan';\n\nmodule.exports = {\n  network,\n  dReg: {\n    abi: require('./ethereum/abi/dReg.json'),\n    address: (() => {\n      switch(network) {\n        case 'kovan':\n          return '0xcaf5A88e50551759eBb44a5e5648b4d6c1932F50';\n        default:\n          return null;\n      }\n    })()\n  },\n  ipfs: {\n    infura: {\n      host: 'ipfs.infura.io',\n      port: 5001,\n      protocol: 'https'\n    }\n  }\n};\n","import React, { Component } from 'react';\nimport { network } from '../../env';\n\nconst ethers = require('ethers');\n\nexport default class extends Component {\n  openEraSwapLife = () => {\n    window.open('https://eraswap.life/','','width=1001,height=650');\n  }\n\n  render = () => (\n    <>\n      <button onClick={this.openEraSwapLife}>Load Wallet Using Era Swap Life</button>\n      <button onClick={() => window.wallet = ethers.Wallet.createRandom().connect(ethers.getDefaultProvider(network))}>Random Wallet</button>\n    </>\n  );\n}\n","const { ipfs } = require('./env');\nconst IPFS = require('ipfs-http-client');\nconst bs58 = require('bs58');\nconst ethers = require('ethers');\n\nconst ipfsClient = new IPFS(ipfs.infura);\n\n// data should be hex string or uint8 array\nasync function add(input) {\n  let data;\n  if(typeof input === 'string') {\n    if(input.slice(0, 2) === '0x') {\n      data = ethers.utils.arrayify(input);\n    } else {\n      data = ethers.utils.toUtf8Bytes(input);\n    }\n  } else if(input instanceof Uint8Array && input.filter(n => n >= 256).length === 0) {\n    data = input;\n  } else {\n    window.ssss = input;\n    console.log({input, first: Array.isArray(input), second: input.filter(n => n >= 256).length === 0});\n    throw new Error('Invalid input: ' + input);\n  }\n\n  const asyncGenerator = ipfsClient.add(input);\n  const output = await asyncGenerator.next();\n  return output.value.path;\n}\n\nasync function get(ipfsHash) {\n  const asyncGenerator = ipfsClient.get(ipfsHash);\n  const output = await asyncGenerator.next();\n  const contentGenerator = output.value.content;\n  const content = await contentGenerator.next();\n  // console.log({content});\n  return content.value._bufs.length === 1\n    ? content.value._bufs[0]\n    : content.value._bufs;\n}\n\nfunction multihashToBytes32(ipfsHash) {\n  const decoded = bs58.decode(ipfsHash);\n  if(decoded.length !== 34) throw new Error(`Invalid IPFS Hash Size: ${decoded.length} bytes`);\n  return decoded.slice(2);\n}\n\nfunction toMultihash(bytes32) {\n  const hex = ethers.utils.hexlify(bytes32);\n  return bs58.encode(ethers.utils.concat(['0x1220', hex]));\n}\n\nconst ipfsUtils = { bs58, add, get, multihashToBytes32, toMultihash };\n\nexport default ipfsUtils;\n","import React, { Component } from 'react';\nimport { IPFS_ADD_STATUS_ENUM, ETH_TX_CONFIRM_ENUM } from '../../../../enums';\nimport ipfsUtils from '../../../../ipfs-utils';\nconst ethers = require('ethers');\n\nexport default class extends Component {\n  state = {\n    name: '',\n    location: '',\n    url: '',\n    bio: '',\n    ipfsHash: null,\n    ipfsStatus: IPFS_ADD_STATUS_ENUM.IDLE,\n    txStatus: ETH_TX_CONFIRM_ENUM.IDLE,\n    errorMessage: ''\n  };\n\n  componentDidMount = () => {\n    if(window.profileObj) {\n      this.setState({\n        name: window.profileObj.name,\n        location: window.profileObj.location,\n        url: window.profileObj.url,\n        bio: window.profileObj.bio\n      });\n    }\n  };\n\n  render = () => {\n    return (\n      <>\n        <p><button onClick={this.props.hideProfile}>{'<< Go Back'}</button> Register form</p>\n        Name: <input\n          placeholder=\"Enter your name\"\n          value={this.state.name}\n          onChange={event => this.setState({ name: event.target.value })}\n          /><br />\n        Location: <input\n          placeholder=\"Enter your location\"\n          value={this.state.location}\n          onChange={event => this.setState({ location: event.target.value })}\n          /><br />\n        Url: <input\n          placeholder=\"Enter your URL\"\n          value={this.state.url}\n          onChange={event => this.setState({ url: event.target.value })}\n          /><br />\n        Bio: <textarea\n          placeholder=\"Tell me about yourself\"\n          value={this.state.bio}\n          onChange={event => this.setState({ bio: event.target.value })}\n          ></textarea>\n        <button disabled={this.state.ipfsStatus !== IPFS_ADD_STATUS_ENUM.IDLE} onClick={async() => {\n          try {\n            this.setState({ ipfsStatus: IPFS_ADD_STATUS_ENUM.UPLOADING });\n            const data = {\n              version: 1,\n              name: this.state.name,\n              location: this.state.location,\n              url: this.state.url,\n              bio: this.state.bio\n            };\n            const bytes = ethers.utils.toUtf8Bytes(JSON.stringify(data));\n            const ipfsHash = await ipfsUtils.add(bytes);\n            this.setState({ ipfsHash, ipfsStatus: IPFS_ADD_STATUS_ENUM.UPLOADED });\n          } catch (error) {\n            this.setState({\n              errorMessage: error.message,\n              ipfsStatus: IPFS_ADD_STATUS_ENUM.IDLE\n            });\n          }\n        }}>{(() => {\n          switch(this.state.ipfsStatus) {\n            case IPFS_ADD_STATUS_ENUM.IDLE:\n              return <>Generate IPFS Hash</>;\n            case IPFS_ADD_STATUS_ENUM.UPLOADING:\n              return <>Uploading...</>;\n            case IPFS_ADD_STATUS_ENUM.UPLOADED:\n              return <>Uploaded!</>;\n          }\n        })()}</button>\n        {this.state.ipfsHash ? <>\n          New IPFS Hash: {this.state.ipfsHash}\n          <button disabled={this.state.txStatus !== ETH_TX_CONFIRM_ENUM.IDLE} onClick={async() => {\n            this.setState({ txStatus: ETH_TX_CONFIRM_ENUM.SIGNING });\n            const bytes32 = ipfsUtils.multihashToBytes32(this.state.ipfsHash);\n            const tx = await window.dRegContract.functions.updateProfile(bytes32);\n            console.log(tx.hash);\n            this.setState({ txStatus: ETH_TX_CONFIRM_ENUM.WAITING });\n            await tx.wait();\n            this.setState({ txStatus: ETH_TX_CONFIRM_ENUM.CONFIRMED });\n            this.props.updateProfileObj(this.state.ipfsHash);\n          }}>{(() => {\n            switch(this.state.txStatus) {\n              case ETH_TX_CONFIRM_ENUM.IDLE:\n                return <>Sign and Submit Update Profile Tx</>;\n              case ETH_TX_CONFIRM_ENUM.SIGNING:\n                return <>Signing...</>;\n              case ETH_TX_CONFIRM_ENUM.WAITING:\n                return <>Waiting for confirmation</>;\n              case ETH_TX_CONFIRM_ENUM.CONFIRMED:\n                return <>Profile Updated</>;\n            }\n          })()}</button>\n          <br />\n          {this.state.txStatus === ETH_TX_CONFIRM_ENUM.CONFIRMED ? <button onClick={this.props.hideProfile}>Back to Home</button> : null}\n        </> : null}\n      </>\n    );\n  }\n}\n","import React, { Component } from 'react';\nimport { dReg, network, ipfs } from '../../../env';\nimport { REGISTRATION_STATUS_ENUM, IPFS_GET_STATUS_ENUM } from '../../../enums';\nimport ipfsUtils from '../../../ipfs-utils';\nimport EditProfile from './EditProfile/EditProfile';\n\nconst ethers = require('ethers');\n\nexport default class extends Component {\n  state = {\n    registrationStatus: REGISTRATION_STATUS_ENUM.CHECKING,\n    ipfsGetStatus: IPFS_GET_STATUS_ENUM.IDLE,\n    // profileObj: null,\n    showEditProfile: false,\n    errorMessage: ''\n  };\n\n  componentDidMount = async() => {\n    // window.dRegContract = new ethers.Contract(dReg.address, dReg.abi, ethers.getDefaultProvider(network));\n    //\n    // window.dRegContract = window.dRegContract.connect(window.wallet);\n\n    const profileStruct = await window.dRegContract.functions.profiles(window.wallet.address);\n\n    await this.setState({\n      registrationStatus: profileStruct.ipfsSha256Hash === ethers.constants.HashZero\n        ? REGISTRATION_STATUS_ENUM.NOT_REGISTERED\n        : REGISTRATION_STATUS_ENUM.REGISTERED,\n      ipfsGetStatus: IPFS_GET_STATUS_ENUM.LOADING\n    });\n\n    if(this.state.registrationStatus === REGISTRATION_STATUS_ENUM.REGISTERED) {\n      this.updateProfileObj(profileStruct.ipfsSha256Hash);\n    }\n  }\n\n  updateProfileObj = async hash => {\n    try {\n      let ipfsHash = hash;\n      try {\n        ipfsHash = ipfsUtils.toMultihash(hash);\n      } catch (error) {}\n      const bytes = await ipfsUtils.get(ipfsHash);\n\n      const profileObj = JSON.parse(ethers.utils.toUtf8String(bytes));\n      console.log({profileObj});\n\n      window.profileObj = profileObj;\n\n      this.setState({\n        ipfsGetStatus: IPFS_GET_STATUS_ENUM.LOADED,\n        // profileObj\n      });\n    } catch (error) {\n      console.log(error);\n      this.setState({\n        errorMessage: error.message,\n        ipfsGetStatus: IPFS_GET_STATUS_ENUM.NOT_FOUND,\n      });\n    }\n  };\n\n  render = () => {\n    return (\n      <>\n        {\n          !this.state.showEditProfile\n          ? <>\n            <p>{(() => {\n              switch(this.state.registrationStatus) {\n                case REGISTRATION_STATUS_ENUM.CHECKING:\n                  return <>Checking your registration status...</>;\n                case REGISTRATION_STATUS_ENUM.NOT_REGISTERED:\n                  return <>You have not registered.<br />\n                  <button onClick={() => this.setState({\n                    showEditProfile: true\n                  })}>Register Now</button></>;\n                case REGISTRATION_STATUS_ENUM.REGISTERED:\n                  return <>\n                    You are registered<br />\n                    {(() => {\n                      switch(this.state.ipfsGetStatus) {\n                        case IPFS_GET_STATUS_ENUM.LOADING:\n                          return <>Fetching your profile details from IPFS...</>;\n                        case IPFS_GET_STATUS_ENUM.LOADED:\n                          return <>\n                            Successfully, fetched your profile from IPFS.<br />\n                            <button onClick={() => this.setState({\n                              showEditProfile: true\n                            })}>Edit Profile</button>\n                          </>;\n                        case IPFS_GET_STATUS_ENUM.NOT_FOUND:\n                          return <>Looks like your profile was dropped from IPFS, kindly re-update your profile.</>;\n                      }\n                    })()}\n                  </>;\n                default:\n                  return null;\n              }\n            })()}</p>\n          </>\n          : <EditProfile\n              hideProfile={() => this.setState({ showEditProfile: false })}\n              updateProfileObj={this.updateProfileObj}\n            />\n        }\n      </>\n    );\n  }\n}\n","import React, { Component } from 'react';\nimport ipfsUtils from '../../../../ipfs-utils';\n\nconst ethers = require('ethers');\n\nexport default class extends Component {\n  state = {\n    userAddress: null,\n    multiHash: null,\n    name: null,\n    location: null,\n    url: null,\n    bio: null\n  };\n\n  componentDidMount = async() => {\n    const userAddress = this.props.userAddress;\n    const ipfsSha256Hash = this.props.ipfsSha256Hash;\n    const multiHash = ipfsUtils.toMultihash(ipfsSha256Hash);\n\n    console.log(`h: ${this.props.h}`, {ipfsSha256Hash}, {multiHash});\n    this.setState({ userAddress, multiHash });\n\n\n    const bytes = await ipfsUtils.get(multiHash);\n\n    const profileObj = JSON.parse(ethers.utils.toUtf8String(bytes));\n    // console.log({profileObj});\n    this.setState({\n      name: profileObj.name,\n      location: profileObj.location,\n      url: profileObj.url,\n      bio: profileObj.bio,\n    });\n  };\n\n  render = () => {\n    return (\n      <div class=\"timeline-element\">\n        <span className=\"el-key\">Address:</span> {this.state.userAddress}<br />\n        <span className=\"el-key\">IPFS:</span> {this.state.multiHash}<br />\n        <span className=\"el-key\">Name:</span> {this.state.name}<br />\n        <span className=\"el-key\">Location:</span> {this.state.location}<br />\n        <span className=\"el-key\">Url:</span> <a href={this.state.url} target=\"_blank\">{this.state.url}</a><br />\n        <span className=\"el-key\">Bio:</span> {this.state.bio}\n      </div>\n    );\n  }\n}\n","import React, { Component } from 'react';\nimport TimelineElement from './TimelineElement/TimelineElement';\nimport ipfsUtils from '../../../ipfs-utils';\n\nconst ethers = require('ethers');\n\nexport default class extends Component {\n  state = {\n    fetchingLogs: true,\n    logs: [],\n    newLogs: []\n  };\n\n  componentDidMount = async() => {\n    this.updateLogs();\n\n    window.wallet.provider.on(window.dRegContract.filters.ProfileUpdated(), log => {\n      // const parsed = window.dRegContract.interface.parseLog(log);\n      // // console.log('parsed', parsed);\n      // const newLogs = [parsed, ...this.state.newLogs];\n      // // console.log('new logs', newLogs);\n      // this.setState({ newLogs });\n\n      this.updateLogs();\n    });\n  }\n\n  updateLogs = async() => {\n    this.setState({ fetchingLogs: true });\n\n    const logs = (await window.wallet.provider.getLogs({\n      ...window.dRegContract.filters.ProfileUpdated(),\n      fromBlock: 0,\n      toBlock: 'latest'\n    })).map(log => window.dRegContract.interface.parseLog(log)).reverse();\n    console.log({logs});\n\n    this.setState({ logs, fetchingLogs: false });\n  }\n\n  render = () => {\n    return (\n      <>\n        {\n          this.state.fetchingLogs\n          ? <p>Please wait fetching logs...</p>\n          : <>\n\n            {this.state.logs.map((log, i) => {\n              const userAddress = log.values._userAddress;\n              const ipfsSha256Hash = log.values._ipfsSha256Hash;\n              return <TimelineElement\n                key={i}\n                userAddress={userAddress}\n                ipfsSha256Hash={ipfsSha256Hash}\n                h={i}\n                />\n            })}\n          </>\n        }\n      </>\n    );\n  }\n}\n","import React, { Component } from 'react';\nimport { dReg, network, ipfs } from '../../env';\nimport { REGISTRATION_STATUS_ENUM, IPFS_GET_STATUS_ENUM } from '../../enums';\n\nimport UserDashboard from './UserDashboard/UserDashboard';\nimport EditProfile from './UserDashboard/EditProfile/EditProfile';\nimport PublicTimeline from './PublicTimeline/PublicTimeline';\n\nimport ipfsUtils from '../../ipfs-utils';\nconst ethers = require('ethers');\n\nexport default class extends Component {\n  state = {\n    name: null,\n    showTimeLine: false,\n  };\n\n  componentDidMount = () => {\n    setInterval(() => {\n      if(window.profileObj && window.profileObj.name !== this.state.name) {\n        this.setState({ name: window.profileObj.name });\n      }\n    }, 100);\n  };\n\n  render = () => {\n    return (\n      <>\n        <p>Welcome {this.state.name ? <>{this.state.name}</> : <>{window.wallet.address}</>}!</p>\n        {\n          !this.state.showTimeLine\n          ? <>\n              <UserDashboard />\n              <button onClick={() => this.setState({ showTimeLine: true })}>Show Public Timeline</button>\n            </>\n          : <>\n              <button onClick={() => this.setState({ showTimeLine: false })}>Show My Dashboard</button>\n              <PublicTimeline />\n            </>\n        }\n      </>\n    );\n  }\n}\n","import React, { Component } from 'react';\nimport logo from './logo.svg';\nimport './App.css';\n\nimport LoadWallet from './components/LoadWallet/LoadWallet';\nimport Home from './components/Home/Home';\n\nexport default class extends Component {\n  state = {\n    walletLoaded: false\n  };\n\n  componentDidMount = () => {\n    setInterval(() => {\n      const walletLoaded = window.wallet !== undefined;\n      if(walletLoaded !== this.state.walletLoaded) {\n        this.setState({ walletLoaded });\n      }\n    }, 100);\n  };\n\n  render = () => (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        {\n          !this.state.walletLoaded\n          ? <LoadWallet />\n          : <Home />\n        }\n      </header>\n    </div>\n  );\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport { dReg, network } from './env';\nimport ipfsUtils from './ipfs-utils';\n\nconst ethers = require('ethers');\n\nwindow.ethers = ethers;\nwindow.ipfsUtils = ipfsUtils;\n\nwindow.dRegContract = new ethers.Contract(dReg.address, dReg.abi, ethers.getDefaultProvider(network));\n\n// for development\n// window.wallet = (new ethers.Wallet(\n//   '24C4FE6063E62710EAD956611B71825B778B041B18ED53118CE5DA5F02E494BA'))\n//   .connect(ethers.getDefaultProvider(network));\n// window.dRegContract = window.dRegContract.connect(window.wallet);\n\nwindow.addEventListener('message', function(e) {\n  setTimeout(() => {\n    window.ProcessParentMessage_2(e.data);\n  }, 0);\n} , false);\n\nwindow.ProcessParentMessage_2 = message => {\n  if(typeof message === 'string'){\n    if(message.substring(0,2) === \"0x\"){\n      window.wallet = (new ethers.Wallet(message)).connect(ethers.getDefaultProvider(network));\n      window.dRegContract = window.dRegContract.connect(window.wallet);\n    }\n  }\n}\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","const REGISTRATION_STATUS_ENUM = {\n  CHECKING: 0,\n  NOT_REGISTERED: 1,\n  REGISTERED: 2\n};\n\nconst IPFS_ADD_STATUS_ENUM = {\n  IDLE: 0,\n  UPLOADING: 1,\n  UPLOADED: 2\n};\n\nconst IPFS_GET_STATUS_ENUM = {\n  IDLE: 0,\n  LOADING: 1,\n  LOADED: 2,\n  NOT_FOUND: 3\n};\n\nconst ETH_TX_CONFIRM_ENUM = {\n  IDLE: 0,\n  SIGNING: 1,\n  WAITING: 2,\n  CONFIRMED: 3\n}\n\nmodule.exports = { REGISTRATION_STATUS_ENUM, IPFS_ADD_STATUS_ENUM, IPFS_GET_STATUS_ENUM, ETH_TX_CONFIRM_ENUM };\n"],"sourceRoot":""}